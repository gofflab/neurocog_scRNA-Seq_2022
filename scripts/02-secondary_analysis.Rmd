---
title: "02 - Secondary Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Overview

## Learning Objectives

• Understand the basic steps of single cell RNA-Sequencing analysis workflows
• Develop a baseline appreciation for cellular heterogeneity both between and within cell types
• Identify cell state transitions via pseudotime and RNA Velocity analysis and interpret meanings in an embedding

## Data

### Description

### Download
The dataset we are using is [10x 10k neurons from an E18 mouse](https://support.10xgenomics.com/single-cell-gene-expression/datasets/3.0.0/neuron_10k_v3) (This is a large dataset ~25Gb).

Cells for this sample are from a combined cortex, hippocampus and sub ventricular zone of an E18 mouse.
- 11,843 cells detected
- Sequenced on Illumina NovaSeq with approximately 30,000 reads per cell
- 28bp read1 (16bp Chromium barcode and 12bp UMI), 91bp read2 (transcript), and 8bp I7 sample barcode

![10x Genomics sequencing workflow overview](https://dnacore.missouri.edu/images/10xschematic.jpg)

Experimental questions:
- What types of cells do we expect to find?
- What/how many cellular 'states' do we observe at the transcriptional level?
- How well defined are different cell types
  * What do 'transitioning' cell types/states look like?
- Can we identify differentially expressed and/or marker genes between cell types?
- What genes change expression over the course of neuronal development?


# Library imports
```{r}
library(monocle3)
```

Example $genes X cells$ matrix of Unique Molecular Identifier (UMI) counts:

|     |cell1 |cell2 |cell3 |
|-----|-----:|-----:|-----:|
|gene1|  0   |2     |    0|
|gene2|  15  |7     |    3|
|gene3|  1   |0     |    2|
...

# Monocle3 secondary analysis
That concludes the preprocessing and initial filtering to remove empty droplets, now we will need to import the spliced count matrix into a single cell analysis framework for downstream/secondary analysis. Here we will be using the monocle3 framework.

## Create Monocle `cell_data_set` object from spliced matrix
The `cell_data_set` class defines how the single cell data are stored, indexed, manipulated, and sliced. The three components that we need to create a `cell_data_set` instance are 1) the sparse count matrix, 2) gene-level annotation, and 3) cell-level annotation.  We don't have much for #'s 2 or 3 at this point other than ids, but it's enough to get started.
```{r monocle3_create_cds}
cellMeta<-data.frame("barcode"=colnames(sf))
rownames(cellMeta)<-cellMeta$barcode
geneMeta<-data.frame("gene_id"=rownames(sf))
rownames(geneMeta)<-geneMeta$gene_id
dat <- monocle3::new_cell_data_set(sf,
                         cell_metadata = cellMeta,
                         gene_metadata = geneMeta)
```
We have now created our base monocle3 `cell_data_set` object called `dat`. Lets peek around to see what's inside:

```{r}
dat
```
This is a summary report of `dat`.

To access the expression matrix we use the `exprs()` method:
```{r}
assay(dat,'counts')[1:6,1:6]
```

To access the gene annotations we use the `rowData()` method:
```{r}
rowData(dat)
```

To access the cell annotations we use the `colData()` method:
```{r}
colData(dat)
```
