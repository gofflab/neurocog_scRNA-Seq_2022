---
title: "Neurocog II scRNA-Seq Lab - 2020"
author: "Loyal Goff"
date: "2/14/2020"
output: html_document
---
_This tutorial has been adapted for NeurocogII 2020 from several sources including:_
[RNA velocity with kallisto | bus and velocyto.R](https://bustools.github.io/BUS_notebooks_R/velocity.html)
[Monocle3 vignettes](https://cole-trapnell-lab.github.io/monocle3/)

```{r setup, include=FALSE}
knitStart <- Sys.time()
knitr::opts_chunk$set(echo = TRUE)
#source('scripts/utils.R')
```

# Environment Setup
First we will install any needed software packages.  This may take a while the first time through. By default these code chunks are not evaluated, you will have to change `eval=TRUE` to force them to install.

```{r devtools_install, eval=FALSE}
# Install devtools if it's not already installed
if (!require(devtools)) {
  install.packages("devtools")
}
# Install from GitHub
devtools::install_github("mannau/h5")
devtools::install_github("BUStools/BUSpaRse")
devtools::install_github("satijalab/seurat-wrappers")
devtools::install_github("LTLA/SingleR")
devtools::install_github('linxihui/NNLM')
devtools::install_github('cvarrichio/Matrix.utils')
```

## Install BioC packages
```{r Bioc_install, eval = FALSE}
if (!require(BiocManager)) {
  install.packages("BiocManager")
  BiocManager::install(c("DropletUtils", "BSgenome.Mmusculus.UCSC.mm10",
                       "AnnotationHub", "SingleR","celldex","biomaRt","tidyverse","scales","zeallot","densityClust"))
}
```

## Install monocle3
```{r monocle3_install, eval = FALSE}
if (!require(monocle3)) {
  BiocManager::install(c('BiocGenerics', 'DelayedArray', 'DelayedMatrixStats',
                       'limma', 'S4Vectors', 'SingleCellExperiment',
                       'SummarizedExperiment', 'batchelor','fgsea'))
  devtools::install_github('cole-trapnell-lab/leidenbase') # clustering package dependency for monocle3
  devtools::install_github('cole-trapnell-lab/monocle3')
  devtools::install_github('scfurl/m3addon') # Monocle3 addon functions from scfurl (optionally included to illustrate high-variance gene identification)
}
```

## Install Velocyto.R
For velocity applications via `velocyto.R` you will need to have boost (e.g. sudo apt-get install libboost-dev) and openmp libraries installed. Instructions for this are not provided in the tutorial. *If you cannot get velocyto.R to install, please skip this section.*
```{r velocyto_install, eval = FALSE}
if (!require(velocyto.R)) {
  BiocManager::install(c("pcaMethods"))
  devtools::install_github("velocyto-team/velocyto.R")
}
```

## Load required libraries
Once we have installed the necessary packages, we can load them into the R session to begin our analysis.
```{r load_packages, message=FALSE, warning=FALSE}
library(AnnotationHub)
library(biomaRt)
library(BSgenome.Mmusculus.UCSC.mm10)
library(tidyverse)
library(velocyto.R)
library(BUSpaRse)
library(scales)
library(zeallot)
library(DropletUtils)
library(SingleR)
library(celldex)
library(NNLM)
library(monocle3)
theme_set(theme_bw()) # Setting a more pleasing default theme
```

# Overview

## Learning Objectives

• Understand the basic steps of single cell RNA-Sequencing analysis workflows
• Develop a baseline appreciation for cellular heterogeneity both between and within cell types
• Identify cell state transitions via pseudotime and RNA Velocity analysis and interpret meanings in an embedding


## Data

### Description

### Download
The dataset we are using is [10x 10k neurons from an E18 mouse](https://support.10xgenomics.com/single-cell-gene-expression/datasets/3.0.0/neuron_10k_v3) (This is a large dataset ~25Gb).

Cells for this sample are from a combined cortex, hippocampus and sub ventricular zone of an E18 mouse.
- 11,843 cells detected
- Sequenced on Illumina NovaSeq with approximately 30,000 reads per cell
- 28bp read1 (16bp Chromium barcode and 12bp UMI), 91bp read2 (transcript), and 8bp I7 sample barcode

![10x Genomics sequencing workflow overview](https://dnacore.missouri.edu/images/10xschematic.jpg)

Experimental questions:
- What types of cells do we expect to find?
- What/how many cellular 'states' do we observe at the transcriptional level?
- How well defined are different cell types
  * What do 'transitioning' cell types/states look like?
- Can we identify differentially expressed and/or marker genes between cell types?
- What genes change expression over the course of neuronal development?

First, we will need to download the dataset, unless it has already been downloaded for you.
```{r dl_data}
# Download data
# If error, please make sure that data directory exists off of project root (e.g. dir.create('data'))
if (!file.exists("./data/neuron_10k_v3_fastqs.tar")) {
  download.file("http://s3-us-west-2.amazonaws.com/10x.files/samples/cell-exp/3.0.0/neuron_10k_v3/neuron_10k_v3_fastqs.tar", "./data/neuron_10k_v3_fastqs.tar", method = "wget", quiet = TRUE)
}
```

```{r, include=FALSE}
do_untar <- !dir.exists("./data/neuron_10k_v3_fastqs")
do_index <- !file.exists("./output/mm_cDNA_introns_ensembl97.idx")
do_bus <- !file.exists("./output/neuron10k_velocity/output.bus")
```

After downloading, we need to expand (uncompress) the files
```{bash, eval=do_untar}
cd ./data
tar -xvf ./neuron_10k_v3_fastqs.tar
```

# Kallistobus workflow - single cell preprocessing
Since we are downloading the raw sequencing reads for this single cell project, we will first have to 'preprocess' the data. In this step, the reads will be 1) mapped to a reference transcriptome to determine from which gene they are derived, 2) 'demultiplexed' or assigned to specific cells based on the presence of a cell-specific barcode sequence, and 3) duplicate reads from the same cell:gene fragment will be collapsed using a 'unique molecular identifier' (UMI).

This notebook demonstrates the use of command line tools `kallisto` and `bustools`. Please use `kallisto` >= 0.46, whose binary can be downloaded [here](https://pachterlab.github.io/kallisto/download). Also, please use `bustools` >= 0.39.3, whose binary of `bustools` can be found [here](https://github.com/BUStools/bustools/releases). User interface of `bustools` has changed in version 0.39.3. For version 0.39.2, see earlier git commits of this notebook.

After you download the binary, you should decompress the file (if it is `tar.gz`) with `tar -xzvf file.tar.gz` in the `bash` terminal, and add the directory containing the binary to `PATH` by `export PATH=$PATH:/foo/bar`, where `/foo/bar` is the directory of interest. Then you can directly invoke the binary on the command line as we will do in this notebook.

## Get gene annotations to prepare a reference index
In order to map the read sequences to their cognate genes/transcripts, we first must download and prepare a reference transcriptome. Here we are using the mouse reference transcriptome from [Ensembl version 97](http://jul2019.archive.ensembl.org/Mus_musculus/Info/Index).  We download this dataset using a standard Bioconductor 'AnnotationHub' workflow.
```{r ann_hub, eval=TRUE}
# query AnnotationHub for mouse Ensembl annotation
ah <- AnnotationHub() # Connect to the Annotation Hub to query.
record<-query(ah,pattern = c("Ensembl", "97", "Mus musculus", "EnsDb")) # Identify the AnnotationHub record associated with Mouse Ensembl v97
```

Once we've identified the AnnotationHub record id `r names(record)` for Mouse Ensembl v97, we can use this to retrieve all of the annotation records for this build.
```{r ann_hub_fetch, eval=TRUE}
# Get mouse Ensembl 97 annotation
edb <- ah[[names(record)]] # I need to comment this out to get the material to build currently...Please uncomment if you are running yourself.
```

## Get and Organize Required Preprocessing Files
As part of this exercise, we will be performing an RNA Velocity analysis (detailed below).  This requires us to generate two seperate count matrices, one for reads mapping to 'spliced' transcripts and one for reads mapping to 'unspliced' transcripts. To do this dual mapping, we need to extract the information that we need to separately map the reads to cDNA sequences as well as intronic sequences. The `BUSpaRse` library has a function `get_velocity_files()` that will extract and process the necessary information from an `AnnotationHub` object.

_*Note:* While this approach generates both the spliced and unspliced annotation records, for most of the downstream analysis we will just be using the count matrices associated with the spliced read mappings._
```{r do_velo_file_test, include = FALSE}
do_files <- !file.exists("./output/neuron10k_velocity/cDNA_introns.fa")
```

```{r get_velo_files, eval=do_files}
get_velocity_files(edb, L = 91, Genome = BSgenome.Mmusculus.UCSC.mm10,
                   out_path = "./output/neuron10k_velocity",
                   isoform_action = "separate")
```
This has created all the necessary annotation files and dumped them into the directory `./output/neuron10k_velocity`

## Build Reference index
Once we have the files for the cDNA sequences and the intronic sequences, we need to construct a reference kallisto index for the mapping.  This indexing scans through the reference transcriptome and organizes it in a way that makes mapping the read sequences faster and more efficient.
```{r do_index_test, include=FALSE}
do_untar <- !dir.exists("./data/neuron_10k_v3_fastqs")
do_index <- !file.exists("./output/mm_cDNA_introns_97.idx")
do_bus <- !file.exists("./output/neuron10k_velocity/output.bus")
```

```{bash kallisto_index, eval=do_index}
# Intron index
kallisto index -i ./output/mm_cDNA_introns_97.idx ./output/neuron10k_velocity/cDNA_introns.fa
```

## Using the `kb` wrapper
With `kallisto` and `bustools`, it takes several commands to go from fastq files to the spliced and unspliced matrices, which is quite cumbersome. So a wrapper called `kb` was written to condense those steps to one. The command line tool `kb` can be installed with

```{bash install_kb_python, eval = FALSE}
conda activate kallistobus
pip install kb-python
```

Once you have this installed, we can then we can use the following command to generate the spliced and unspliced count matrices from the raw reads and the assembled reference index. The count matrix files will be the primary data sources for the downstream/secondary analysis.

Example $genes X cells$ matrix of Unique Molecular Identifier (UMI) counts:

|     |cell1 |cell2 |cell3 |
|-----|-----:|-----:|-----:|
|gene1|  0   |2     |    0|
|gene2|  15  |7     |    3|
|gene3|  1   |0     |    2|
...

```{bash do_kb_python, eval = FALSE}
cd ./output/neuron10k_velocity
kb count -i ../mm_cDNA_introns_97.idx -g tr2g.tsv -x 10xv3 -o kb \
-c1 cDNA_tx_to_capture.txt -c2 introns_tx_to_capture.txt --lamanno \
../../data/neuron_10k_v3_fastqs/neuron_10k_v3_S1_L002_R1_001.fastq.gz \
../../data/neuron_10k_v3_fastqs/neuron_10k_v3_S1_L002_R2_001.fastq.gz \
../../data/neuron_10k_v3_fastqs/neuron_10k_v3_S1_L001_R1_001.fastq.gz \
../../data/neuron_10k_v3_fastqs/neuron_10k_v3_S1_L001_R2_001.fastq.gz
```

<!-- ## Make spliced and unspliced matrices -->
<!-- ```{r, include=FALSE} -->
<!-- do_copy <- !file.exists("./data/whitelist_v3.txt") -->
<!-- do_bustools <- !file.exists("./output/neuron10k_velocity/kb/output.correct.sort.bus") -->
<!-- do_count <- !file.exists("./output/neuron10k_velocity/kb/spliced.mtx") -->
<!-- ``` -->

<!-- A barcode whitelist of all valid barcode can be used, though is not strictly required. The 10x whitelist contains all barcodes from the kit. The 10x whitelist file comes with Cell Ranger installation, and is copies to the working directory of this notebook. For `bustools`, the whitelist must be a text file with one column, each row of which is a valid cell barcode. The text file must not be compressed. If you do not have a whitelist, the most recent version of `bustools` can generate one based on data. The `bustools whitelist` command can also remove barcodes with too few reads, which means removing what may be empty droplets. -->
<!-- ```{bash, eval=do_copy} -->
<!-- cp /Volumes/Data/indexes/10x/whitelist/V3/3M-february-2018.txt.gz ./data/whitelist_v3.txt.gz -->

<!-- # Decompress (provided with repo for your convenience) -->
<!-- #mv ./data/3M-february-2018.txt.gz ./data/whitelist_v3.txt.gz -->
<!-- gunzip ./data/whitelist_v3.txt.gz -->

<!-- ``` -->

<!-- ```{bash, eval=do_bustools} -->
<!-- cd ./output/neuron10k_velocity -->
<!-- bustools correct -w ../../../data/whitelist_v3.txt -p output.bus | bustools sort -o output.correct.sort.bus -t4 - -->
<!-- bustools capture -s -x -o spliced.bus -c ./introns_tx_to_capture.txt -e matrix.ec -t transcripts.txt output.correct.sort.bus -->
<!-- bustools capture -s -x -o unspliced.bus -c ./cDNA_tx_to_capture.txt -e matrix.ec -t transcripts.txt output.correct.sort.bus -->
<!-- ``` -->

<!-- Unlike for just a gene count matrix, for RNA velocity, 2 matrices are generated. One for spliced transcripts, and the other for unspliced. -->
<!-- ```{bash, eval=do_count} -->
<!-- cd ./output/neuron10k_velocity -->
<!-- bustools count -o unspliced -g ./tr2g.tsv -e matrix.ec -t transcripts.txt --genecounts unspliced.bus -->
<!-- bustools count -o spliced -g ./tr2g.tsv -e matrix.ec -t transcripts.txt --genecounts spliced.bus -->
<!-- ``` -->

# Preprocessing
Once the above preprocessing is complete, we now have two different matrices: one tallying the number of reads for each gene that mapped to spliced cDNA isoforms, and one for the reads matching unspliced isoforms. As mentioned above, *the bulk of the downstream analysis will be performed on the 'spliced' matrix.* For each matrix, we also have two accessory files: one corresponding to the gene names for each row, and another with the cell IDs (barcodes) for each column. All of these files can be read into R using the function `read_velocity_output()` from `BUSpaRse`:
```{r load_matrices}
d <- "./output/neuron10k_velocity/kb/counts_unfiltered" # top-level directory containing requisite files with 'spliced' and 'unspliced' prefixes.
c(spliced, unspliced) %<-% BUSpaRse::read_velocity_output(spliced_dir = d,
                                                spliced_name = "spliced",
                                                unspliced_dir = d,
                                                unspliced_name = "unspliced")

spliced[1:6,1:6]
unspliced[1:6,1:6]
```

What fraction of UMIs are from unspliced transcripts?
```{r frac_unspliced}
sum(unspliced@x) / (sum(unspliced@x) + sum(spliced@x))
```

We expect around 10,000 cells. There are over 10 times more barcodes here, since most barcodes are from empty droplets. The number of genes is constant and represents 'all annotated genes' from the Ensembl v97 mouse database.
```{r}
dim(spliced)
```

```{r}
dim(unspliced)
```
Here rownames are gene identifiers and column names are the unique cell barcode sequences (cell_id).

Most barcodes only have 0 or 1 UMIs detected.
```{r}
tot_count <- Matrix::colSums(spliced)
summary(tot_count)
```

## Remove empty droplets
Since most of the droplets that are generated by the 10x single cell workflow will _not_ contain cells, we need to identify and remove those 'empty droplets' from each matrix. A commonly used method to estimate the number of empty droplets is barcode ranking knee and inflection points, as those are often assumed to represent transitions between two components of a distribution (in this case 'cells' vs 'background'). While more sophisticated methods exist (e.g. see [`emptyDrops` in `DropletUtils`](https://www.bioconductor.org/packages/devel/bioc/vignettes/DropletUtils/inst/doc/DropletUtils.html#detecting-empty-droplets)), for simplicity, we will use the barcode ranking method here. we will use the spliced matrix for filtering, though both matrices have similar inflection points.

Here we calculate the rank order of the cells based on the number of UMIs for each.
```{r rank_barcodes}
bc_rank <- barcodeRanks(spliced)
bc_uns <- barcodeRanks(unspliced)
```

We can plot number of UMIs on the x axis, and cell barcode rank on the y axis. See [this blog post by Lior Pachter](https://liorpachter.wordpress.com/2019/06/24/rotating-the-knee-plot-and-related-yoga/) for a more detailed explanation.

```{r knee_function}
#' Knee plot for filtering empty droplets
#'
#' Visualizes the inflection point to filter empty droplets. This function plots
#' different datasets with a different color. Facets can be added after calling
#' this function with `facet_*` functions.
#'
#' @param bc_ranks A named list of output from `DropletUtil::barcodeRanks`.
#' @return A ggplot2 object.
#' @importFrom tibble tibble
#' @importFrom purrr map map_dbl
#' @importFrom dplyr distinct
#' @importFrom ggplot2 geom_line geom_hline geom_vline scale_x_log10 scale_y_log10
#' @importFrom tidyr unnest
#' @export
knee_plot <- function(bc_ranks) {
  # purrr pluck shorthand doesn't work on S4Vector DataFrame
  knee_plt <- tibble(rank = map(bc_ranks, ~ .x[["rank"]]),
                     total = map(bc_ranks, ~ .x[["total"]]),
                     dataset = names(bc_ranks)) %>%
    unnest(cols = c(rank, total)) %>%
    distinct() %>%
    dplyr::filter(total > 0)
  annot <- tibble(inflection = map_dbl(bc_ranks, ~ metadata(.x)[["inflection"]]),
                  rank_cutoff = map_dbl(bc_ranks,
                                        ~ max(.x$rank[.x$total >
                                                        metadata(.x)[["inflection"]]])),
                  dataset = names(bc_ranks))
  p <- ggplot(knee_plt, aes(rank, total, color = dataset)) +
    geom_line() +
    geom_hline(aes(yintercept = inflection, color = dataset),
               data = annot, linetype = 2) +
    geom_vline(aes(xintercept = rank_cutoff, color = dataset),
               data = annot, linetype = 2) +
    scale_x_log10() +
    scale_y_log10() +
    labs(x = "Rank", y = "Total UMIs")
  return(p)
}
```

```{r knee}
knee_plot(list(spliced = bc_rank, unspliced = bc_uns)) +
  coord_flip()
```
Here we can see the knee plot (reading from right to left) and we can identify an inflection point where there is a sharp dropoff in the information content for barcodes. This is (theoretically) the transition between barcodes corresponding to droplets that actually contained cells, vs those that only had a background level of RNA. As expected, it's roughtly around the 10,000 cell mark which is how many cells we estimated were loaded.

We will use this inflection point (`r metadata(bc_rank)$inflection` UMIs) to enforce a threshold minimum number of UMIs to filter the barcodes down to only those that contain cells. We can additionally remove any genes with no detectable signal across any cells. We then subset both the spliced and unspliced matrices along both of these dimensions.
```{r filter_matrices}
bcs_use <- colnames(spliced)[tot_count > metadata(bc_rank)$inflection]
# Remove genes that aren't detected
tot_genes <- Matrix::rowSums(spliced)
genes_use <- rownames(spliced)[tot_genes > 0]
sf <- spliced[genes_use, bcs_use]
uf <- unspliced[genes_use, bcs_use]
```

So what are we left with?
```{r}
dim(sf)
```
`r dim(sf)[1]` rows (genes) and `r dim(sf)[2]` columns (cells)

# Monocle3 secondary analysis
That concludes the preprocessing and initial filtering to remove empty droplets, now we will need to import the spliced count matrix into a single cell analysis framework for downstream/secondary analysis. Here we will be using the monocle3 framework.

## Create Monocle `cell_data_set` object from spliced matrix
The `cell_data_set` class defines how the single cell data are stored, indexed, manipulated, and sliced. The three components that we need to create a `cell_data_set` instance are 1) the sparse count matrix, 2) gene-level annotation, and 3) cell-level annotation.  We don't have much for #'s 2 or 3 at this point other than ids, but it's enough to get started.
```{r monocle3_create_cds}
cellMeta<-data.frame("barcode"=colnames(sf))
rownames(cellMeta)<-cellMeta$barcode
geneMeta<-data.frame("gene_id"=rownames(sf))
rownames(geneMeta)<-geneMeta$gene_id
dat <- monocle3::new_cell_data_set(sf,
                         cell_metadata = cellMeta,
                         gene_metadata = geneMeta)
```
We have now created our base monocle3 `cell_data_set` object called `dat`. Lets peek around to see what's inside:

```{r}
dat
```
This is a summary report of `dat`.

To access the expression matrix we use the `exprs()` method:
```{r}
exprs(dat)[1:6,1:6]
```

To access the gene annotations we use the `fData()` method:
```{r}
fData(dat)
```

To access the cell annotations we use the `pData()` method:
```{r}
pData(dat)
```

There's not much annotation in there as of yet, lets see what we can add.
## Add gene-level annotation from BioMaRt
Using the `gene_id` information in the featureData slot, we can fetch external annotations for each gene and merge them so we can get more meaningful gene information.  `biomaRt` is an interface in Bioconductor to get information associated with gene_ids.
```{r feature_annotation}
mart <- biomaRt::useMart(biomart = "ENSEMBL_MART_ENSEMBL",
                         dataset = "mmusculus_gene_ensembl",
                         host = 'ensembl.org')
t2g <- biomaRt::getBM(attributes = c("ensembl_gene_id",
                                     "external_gene_name",
                                     "chromosome_name",
                                     "start_position",
                                     "end_position"
                                     ), mart = mart) # Fetch annotation information for all gene_ids

fData(dat)$gene_id_trimmed<-str_split_fixed(fData(dat)$gene_id,pattern="\\.",2)[,1] #Trim off the version identifier from the gene_ids
fData(dat)<-dplyr::left_join(as.data.frame(fData(dat)),t2g,by=c("gene_id_trimmed" = "ensembl_gene_id"),sort=FALSE,all.x=TRUE,keep=TRUE) # merge annotation into existing fData().
fData(dat)$gene_short_name<-fData(dat)$external_gene_name # make a field named "gene_short_name" in fData()
head(fData(dat)) #Inspect
```
Now we have a bit more useful information associated with each gene.

## Data QC and Filtering
Before we move on to exploration and annotation of the data, we first need to get some summary statistics such as a scaling factor and an estimate of the dispersion for each gene (variance in excess of what is expected for a given model fit).

### Dispersion Estimation
The dispersion estimate is a useful metric to identify genes that have higher variance than expected.  Per-gene technical variance in scRNA-Seq data [is well modeled](http://www.nxn.se/valent/2017/11/16/droplet-scrna-seq-is-not-zero-inflated) by a [negative binomial fit](https://en.wikipedia.org/wiki/Negative_binomial_distribution). Genes with excess variation (overdispersion) _should_ have high biological variation above and beyond the modeled technical variance.

```{r dispersion, eval=FALSE}
dat<-m3addon::calculate_gene_dispersion(dat,id_tag="gene_id")

# Select genes with high dispersion relative to fit
dat<-m3addon::select_genes(dat)
m3addon::plot_gene_dispersion(dat) + scale_color_manual(values=c("black","red"))
```
This plot shows how the variance in gene expression measures changes as a function of the mean expression level for each gene. The fit line is a negative binomial approximation that corresponds to the 'technical variance' expected at all levels of expression.  Genes that have a high residual to this fit have more variance than expected and that _may_ represent additional 'biological variance'.  Subsetting to these genes can help improve downstream analyses by focusing on genes that better segregate different cell types or states.

### Monocle3 preprocessing
The term 'preprocessing' comes up again even though we're past the initial hurdle of generating the matrix. Standard secondary preprocessing for single cell RNA-Seq involves projecting expression data into the top principal components to identify ranked sources of variation. This is usually done after log-transforming the data to stabilize the variance across the dynamic range of gene expression. Monocle3 conveniently provides a function `preprocess_cds()` that will do this transform and PCA analysis. We start with a relatively high number of principal components to estimate, 100.

```{r initial_preprocessing}
dat <- preprocess_cds(dat,
                      num_dim = 100,
                      method = "PCA",
                      norm_method = "log",
                      verbose=T,
                      cores=4)

plot_pc_variance_explained(dat)
```
If we look at the variance explained for each principle component, we can see that it starts to trail off after a point.  We probably won't get much more useful information after 40 or so components. So we subset to only the first 40 components and preprocess again.

```{r nDims_preprocessing}
nDims <- 20 # or 20 works here too downstream
dat <- preprocess_cds(dat,
                      num_dim = nDims,
                      method = "PCA",
                      norm_method = "log",
                      verbose=T,
                      cores=4)
```

### QC metrics
Next we can actually start to assess some of the important quality metrices for each gene and each cell.

#### Minimum number of cells expressing a given gene
It's a good idea, and saves time/effort to identify and only consider genes whose expression levels are detected in a certain number or proportion of cells within your assay.

```{r gene_qc_1}
dat<-detect_genes(dat)
cellCutoff<-20 # This number is arbitrary
expressed_genes <- row.names(subset(fData(dat),
    num_cells_expressed >= cellCutoff))

length(expressed_genes)
```

Once we've detected the number of cells expressing each gene, we can look at the distribution to get a better feel
```{r}
hist(fData(dat)$num_cells_expressed,col="red",breaks=50,main="Number of cells expressing a given gene")
```
Most genes are not detectably expressed in more than one cell (this is the nature of single cell gene expression assays, and gene expression in general)

Lets log transform and look again. This time, we'll add a threshold line showing our cutoff for 'expressed genes'.
```{r}
hist(log10(fData(dat)$num_cells_expressed),col="red",breaks=50,main="log10 Number of cells expressing a given gene")
abline(v=log10(cellCutoff),lty="dashed")

```

We have now identified a total of `r length(expressed_genes)` that are detectably expressed in at least `r cellCutoff` cells in our dataset.

#### Distribution of gene mean copies per cell
What is the average expression level (in mRNA Copies per cell) for each gene?
```{r gene_qc_2}
fData(dat)$mean_cpc<-Matrix::rowMeans(exprs(dat))
hist(log10(fData(dat[expressed_genes,])$mean_cpc),col="purple",breaks=50,main="Mean RNA copies per cell")
```

### Cell QC metrics

#### Distribution of detected genes across cells
How many genes are expressed in a given cell?
```{r cell_qc_1}
hist(pData(dat)$num_genes_expressed,col="darkgreen",breaks=50,main="Number of genes expressed per cell")

```

#### Mt-genome proportion
A high proportion of mitochondrial genes may indicate a lower than ideal capture efficiency for a given cell. Here we identify the subset of mitochondrial genes and look at the proportion of reads mapping to 'mt-' genes vs genomic genes.
```{r cell_qc_mito}
mito_genes<-fData(dat)$gene_id[grepl("^mt-",fData(dat)$gene_short_name)]

pData(dat)$mt_reads <- Matrix::colSums(exprs(dat)[mito_genes,])
pData(dat)$total_reads  <- Matrix::colSums(exprs(dat))
pData(dat)$mito_ratio <- pData(dat)$mt_reads/pData(dat)$total_reads

ggplot(as.data.frame(pData(dat)),
       aes(x = num_genes_expressed, y = mito_ratio)) +
       geom_point() +
       labs(x = "Number of genes", y = "Mitochondrial ratio") +
       scale_color_brewer(palette = "Set1") +
       theme(legend.position = "none") +
       ggtitle("Number of genes vs Mitochondrial ratio") +
       monocle3:::monocle_theme_opts()
```

#### Total mRNAs per cell
To get a general picture of the capture efficiency and depth of information for each cell we can look at the total mRNA mass recovered per cell.
```{r total_mRNAs}
pData(dat)$Total_mRNA<-Matrix::colSums(exprs(dat))

hist(pData(dat)$Total_mRNA,col="darkblue",breaks=50,main="Total mRNAs sequenced per cell")
```

_*Bonus question:*_ How many mRNAs do we *expect* are in a given eukaryotic cell?

For each of the above QC 'criterion' we can define thresholds that can be used to filter cells/genes to improve the quality of the dataset.  Here is usually where obvious doublet cells (more than one cell is associated with a single barcode sequence) or low-quality cells are removed prior to doing any further statistical interpretations.

## Reduce dimensionality and visualize the cells
Now we're ready to visualize the cells. To do so, you can use either t-SNE, which is very popular in single-cell RNA-seq, or UMAP, which is increasingly common. Monocle 3 uses UMAP by default, since it is both faster and better suited for clustering and trajectory analysis in RNA-seq. To reduce the dimensionality of the data down into the X, Y plane so we can plot it easily, we call `reduce_dimension()`:
```{r dim_reduction}
dat <- reduce_dimension(dat,
                        verbose=TRUE,
                        reduction_method="UMAP",
                        cores = 4)
```

To visualize the dimensionality reduction we use `plot_cells()`:
```{r plot_dim_reduction}
plot_cells(dat)
```

And we can look at how different features of the cells are distributed across this embedding. For now we only have technical features to view.
```{r plot_dim_reduction_params}
plot_cells(dat,color_cells_by="num_genes_expressed",cell_size=0.75)
plot_cells(dat,color_cells_by="Total_mRNA",cell_size=0.75)
plot_cells(dat,color_cells_by="mito_ratio",cell_size=0.75)
```
What can we deduce/hypothesize about the embedding (we will formally test later)?  Number of cell types?  Diversity of cell types?

### Embedding shapes
* Sometimes, clearly defined cell types are obvious puncta in a 2D embedding
* Other times, what you think of as a single cell type may be broken up into several 'subtypes'
* Still more, a single cell 'type' may consist of several 'cell states' that might present as more of an amorphous shape in an embedding
* Cells in an ergodic transitioning state may be represented as a 'pseeudotemporal trajectory' as different cells pass through different phases of the transition.   - These trajectories can be _*very*_ useful as a high-resolution timecourse for how cells respond to changes or cues.
* What types of shape:stories might be represented in these clusters? What cell types/states do we expect to find in an E18.5 developing mouse cortex?

We can also map the expression level of individual genes (markers) onto this embedding to start to parse out meaning.
```{r known_genes_1}
plot_cells(dat,genes=c("Sox9","Gad1","Slc17a6","Slc17a7"),cell_size=0.75)

plot_cells(dat,genes=c("Pax6","Eomes","Fezf2","Tle4","Satb2","Pou3f2"),cell_size=0.75)
```

## Cluster similar cells into 'cell types'
We next want to impose a clustering solution onto this embedding to group cells with similar transcriptional profiles together. We use `cluster_cells()` to perform this function in monocle3:
```{r cluster_leiden}
dat <- cluster_cells(dat,
                     verbose=TRUE,
                     resolution=1e-4)

plot_cells(dat, color_cells_by="cluster", cell_size=0.75, group_label_size = 5, show_trajectory_graph=FALSE)
```
Remember, clustering is a useful _tool_ but is also _*arbitrary*_ for continuous cell-cell transitions.

## De Novo cell type annotation
As a crude first-pass annotation, we can leverage publicly available, bulk RNA-Seq gene expression information for specific cell types to try and 'learn' cell type annotations for each cell. This 'transfer learning' approach can provide a resonable starting point for coarse cell type identification. The `SingleR` package  leverages reference transcriptomic datasets of pure cell types to infer the cell of origin of each of the single cells independently. First we need to fetch a reference dataset of bulk RNA-Seq expression profiles.

```{r singleR_ref_fetch}
mouse.rnaseq <- celldex::MouseRNAseqData(ensembl = TRUE)
```

```{r, include=FALSE}
do_annot <- !file.exists("./output/neuron10k_velocity/cell_type.rds")
if (!do_annot) {
  annots <- readRDS("./output/neuron10k_velocity/cell_type.rds")
}
```

And then, we can use this dataset to compare our single cell expression profiles against to apply coarse cell type labels.
```{r singleR_annotation, eval=do_annot}

dat.exprs<-exprs(dat[expressed_genes,])
rownames(dat.exprs) <- str_remove(rownames(dat.exprs), "\\.\\d+")

system.time(annots<-SingleR(dat.exprs,
                ref = mouse.rnaseq, labels = colData(mouse.rnaseq)$label.fine,
                de.method = "classic", method = "single", BPPARAM = BiocParallel::MulticoreParam(4))
)
```

```{r annotation_save, include = FALSE, eval=do_annot}
saveRDS(annots, "./output/neuron10k_velocity/cell_type.rds")
```

## Apply learned annotations to cell_data_set object
Once we've learned labels for each cell, we can then add this information into the phenotypeData (`pData()`) slot of our main object.
```{r annotation_assign}
pData(dat)$cell_type <- annots$pruned.labels
plot_cells(dat,color_cells_by="cell_type", group_cells_by = "cluster", cell_size=0.75, label_cell_groups = FALSE)

table(pData(dat)$cell_type)
```

The algorithm does a reasonable job at identifying major cell types, and identifies a number of different cell types in our dataset. Before we go any further, lets filter the dataset down to only cell types that we might be interested in for downstream analysis.

```{r annotation_filter}
inds <- annots$pruned.labels %in% c("NPCs", "Neurons", "OPCs", "Oligodendrocytes",
                                    "qNSCs", "aNSCs", "Astrocytes", "Ependymal")
# Only keep these cell types
cells_use <- row.names(annots)[inds]
dat <- dat[,cells_use]
table(pData(dat)$cell_type)

# Preprocess again on filtered dataset
nDims <- 20

dat <- preprocess_cds(dat,
                      num_dim = nDims,
                      method = "PCA",
                      verbose=TRUE)
dat <- reduce_dimension(dat,
                        verbose=TRUE,
                        reduction_method="UMAP",
                        umap.n_neighbors=20,
                        cores = 4)
dat <- cluster_cells(dat,
                     verbose=TRUE,
                     resolution=1e-5)

plot_cells(dat,color_cells_by="cell_type", group_cells_by = "cluster", cell_size=0.75, label_cell_groups = FALSE) + scale_color_brewer(palette="Set1")
plot_cells(dat,color_cells_by="cluster",cell_size=0.75)
plot_cells(dat,color_cells_by="partition",cell_size=0.75)
plot_cells(dat,genes=c("Pax6","Eomes","Fezf2","Tle4","Satb2","Pou3f2"),cell_size=0.75)

```

## Finding marker genes
One of our objectives is to find marker genes expressed by each cluster/cell type.
Once cells have been clustered, we can ask what genes makes them different from one another. To do that, start by calling the `top_markers()` function:

```{r marker_genes_1, message=FALSE, warning=FALSE, results='hide'}
marker_test_res <- top_markers(dat, group_cells_by="cluster",
                               reference_cells=500, cores=4)
```

```{r}
top_specific_markers <- marker_test_res %>%
                           dplyr::filter(fraction_expressing >= 0.30) %>%
                            group_by(cell_group) %>%
                            top_n(5, pseudo_R2)

top_specific_marker_ids <- unique(top_specific_markers %>% pull(gene_id))

plot_genes_by_group(dat,
                    top_specific_marker_ids,
                    group_cells_by="cluster",
                    ordering_type="maximal_on_diag",
                    max.size=4)

plot_cells(dat,color_cells_by="cluster",cell_size=0.75, group_label_size = 8)
```

# Pseudotime analysis
Pseudotime is a measure of how much progress an individual cell has made through a process such as cell differentiation. Since we have at least one population of cells that is transitioning from a progenitor state to a series of mature neurons, can we identify potential differentiation trajectories?

## Learn trajectory graph
First we must learn a 'trajectory graph' across each partition (contiguous group of cells) in the data.
```{r pseudotime_1}
dat <- learn_graph(dat)

plot_cells(dat,
           color_cells_by = "cell_type",
           label_groups_by_cluster=FALSE,
           label_leaves=TRUE,
           label_branch_points=TRUE,
           label_cell_groups = FALSE,
           graph_label_size=3,
           cell_size=0.75) + scale_color_brewer(palette="Set1")

dat <- order_cells(dat,
                   root_pr_nodes="Y_54")

plot_cells(dat,
           color_cells_by = "pseudotime",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=3,
           cell_size=0.75)
```
Here we are also setting the 'root' of this trajectory to begin at a node in the NPC cells.

## Differential gene expression with respect to pseudotime
How do we find the genes that are differentially expressed on the different paths through the trajectory? How do we find the ones that are restricted to the beginning of the trajectory? Or excluded from it? Monocle3 uses a 'principal graph test' to test whether cells at similar positions on the trajectory have correlated expression
```{r pr_test, cache=TRUE, results='hide'}
system.time(pseudotime_pr_test_res<-graph_test(dat,
                                               neighbor_graph="principal_graph",
                                               cores=4)
)
pr_deg_ids <- row.names(subset(pseudotime_pr_test_res, q_value < 1e-50))
```

Here are some high-scoring differentially expressed genes along the pseudotime trajectory in their UMAP embedding
```{r pr_de_genes_UMAP}
pseudotime_genes <- c("Pax6","Btg2","Snap25","Fezf2","Hes6","Cux1")
#pseudotime_genes <- head(pseudotime_pr_test_res[order(pseudotime_pr_test_res$q_value),])$external_gene_name
plot_cells(dat, genes=pseudotime_genes,
           show_trajectory_graph=TRUE,
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           cell_size=0.5)
```

We can also explicitly look at how the expression of these genes along the pseudotime trajectory. The function `plot_genes_in_pseudotime()` takes a small set of genes and shows you their dynamics as a function of pseudotime:
```{r pr_de_genes_pseudotime}
pseudotime_lineage_cds <- dat[fData(dat)$gene_short_name %in% pseudotime_genes,
                       pData(dat)$cell_type %in% c("NPCs","Neurons")]
plot_genes_in_pseudotime(pseudotime_lineage_cds,
                         color_cells_by="cell_type",
                         min_expr=0.5,
                         ncol=2)
```

### Bonus: 3D trajectories
```{r pseudotime_3d_trajectory}
dat_3d <- reduce_dimension(dat, max_components = 3, cores=4)
dat_3d <- cluster_cells(dat_3d,resolution = 1e-5)
dat_3d <- learn_graph(dat_3d)
#dat_3d <- order_cells(dat_3d)

plot_cells_3d(dat_3d, color_cells_by="cell_type")
```

# Pattern Discovery (NMF)
Finally, we can step beyond marker gene analysis, and use some 'latent space' discovery methods to learn patterns of co-regulated gene expression.

These patterns can be used to identify/define:
  * Cell type identities
  * Biological processes
  * Spatial gradients
  * Other cellular features

... often with significantly greater resolution and precision than marker genes.

Importantly, these patterns are 'data driven' and often yield insights into the heterogeneity and complexity of a given dataset that were unanticipated.

```{r NNMF, warning=FALSE, message=FALSE, cache=TRUE}
nPatterns<-30
# Takes about ~3-4 minutes...
system.time(dat.nnmf<-NNLM::nnmf(as.matrix(log10(exprs(dat)[expressed_genes,]+1)), k = nPatterns,
    n.threads = 6, trace = 10, verbose = TRUE, show.warning = TRUE))

# Gene x Pattern matrix
dim(dat.nnmf$W)

# Pattern x Cell matrix
dim(dat.nnmf$H)

#Add patterns to phenotype data for visualization
patterns.df<-data.frame(t(dat.nnmf$H))
colnames(patterns.df)<-paste0("Pattern_",c(1:nPatterns))

pData(dat)<-cbind(pData(dat),patterns.df)

pdf("figures/patterns.pdf",width=10,height=10)
lapply(c(1:nPatterns),function(i){
plot_cells(dat, color_cells_by=paste0("Pattern_",i), cell_size=0.75) +
    ggtitle(paste0("Pattern_",i))  +
    coord_equal(1)
})
dev.off()

targetPattern<-10
plot_cells(dat, color_cells_by=paste0("Pattern_",targetPattern), cell_size=0.75) +
    ggtitle(paste0("Pattern ",targetPattern))  +
    coord_equal(1)

```

## Genes associated with learned patterns
```{r NNMF_gene_weights}
geneWeights.df<-data.frame(dat.nnmf$W)
colnames(geneWeights.df)<-paste0("Pattern_",c(1:nPatterns))

#fData(dat)[head(rownames(dat.nnmf$W)[order(dat.nnmf$W[,patternOfInterest],decreasing=TRUE)]),]
tmp<-as.data.frame(merge(fData(dat)[,c("gene_id","gene_short_name")],geneWeights.df,by=0))

targetPatterns<-c(5,9,10,23,targetPattern)
DT::datatable(tmp[,c("gene_id","gene_short_name",
                     unlist(lapply(targetPatterns,function(i){paste0("Pattern_",i)
                       }))
                       )])
```

# Velocity analysis
Finally, we can revist the [RNA velocity](https://www.nature.com/articles/s41586-018-0414-6) analysis to make predictions about how cells are traveling through the UMAP embedding. By estimating the potential turnover rates for individual genes, we can then make predictions about where each gene:cell is in this process. By aggregating this information for a given cell, and projecting into the UMAP embedding, we can make an estimate of 'where' each cell will be in this embedding in about an hour.  This helps us understand the flow of cells through these manifold embeddings.

```{r velocity_estimate, eval=FALSE, cache=TRUE}

cell.dist <- as.dist(1-armaCor(t(dat@reducedDims$PCA))) ### TODO: point to cell_data_set PCA projection to calculate cell-cell distance

fit.quantile <- 0.02
system.time(rvel.cd <- gene.relative.velocity.estimates(sf[,cells_use],uf[,cells_use],deltaT=1,kCells=25,fit.quantile=fit.quantile, cell.dist=cell.dist, n.cores=7)) ### TODO: Add cell.dist to velocity estimates
```

```{r velocity_draw, eval=FALSE,cache=TRUE}
emb <- dat@reducedDims$UMAP
nCols<-length(unique(pData(dat)$cell_type))
cell.colors<-rainbow(nCols)[as.factor(pData(dat)$cell_type)]
names(cell.colors)<-colnames(sf[,cells_use])

system.time(velocity_embedding<-show.velocity.on.embedding.cor(emb,
                               rvel.cd,
                               n=200,
                               scale='sqrt',
                               cell.colors=ac(cell.colors,alpha=0.5),
                               cex=0.8,
                               arrow.scale=3,
                               show.grid.flow=TRUE,
                               min.grid.cell.mass=0.5,
                               grid.n=40,
                               arrow.lwd=1
                               ,do.par=F,
                               cell.border.alpha = 0.1,
                               n.cores=6,
                               return.details=TRUE)
)
```

## Gene-specific velocity plots
```{r velocity_genes, eval=FALSE}
gene <- "ENSMUSG00000027210.20" ## Meis2
gene.relative.velocity.estimates(sf[,cells_use],uf[,cells_use],deltaT=1,kCells = 25,kGenes=1,fit.quantile=fit.quantile,cell.emb=emb,cell.colors=cell.colors,cell.dist=cell.dist,show.gene=gene,old.fit=rvel.cd,do.par=T)

gene <- "ENSMUSG00000027168.21" ## Pax6
gene.relative.velocity.estimates(sf[,cells_use],uf[,cells_use],deltaT=1,kCells = 25,kGenes=1,fit.quantile=fit.quantile,cell.emb=emb,cell.colors=ac(cell.colors,alpha=0.5),show.gene=gene,old.fit=rvel.cd,do.par=T)

gene <- "ENSMUSG00000021743.6"
gene.relative.velocity.estimates(sf[,cells_use],uf[,cells_use],deltaT=1,kCells = 100,kGenes=1,fit.quantile=fit.quantile,cell.emb=emb,cell.colors=ac(cell.colors,alpha=0.5),show.gene=gene,old.fit=rvel.cd,do.par=T)

```

# Session Information
```{r session}
sessionInfo()
```

## Knit Time
With caches
```{r}
knitEnd <- Sys.time()
knitEnd - knitStart
```
